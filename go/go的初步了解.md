本文章来源于：<https://github.com/Zeb-D/my-review> ，请star 强力支持，你的支持，就是我的动力。

[TOC]

------

### 一、 Go语言的特点

Go语言跟其他的语言例如Java比起来，算得上一门很年轻的语言。Go语言是由Robert Griesemer、Rob Pike和Ken Thompson于2007年在Google开发。并于2009年正式发布。

Go语言的设计理念围绕着简洁这两个字，认为少即是多。如果你熟悉Java，用Java那一套语法命名跟Go做对比，可以很明显的体会到这种感觉。

Go的特点可以简单的概括成以下几个点。

##### 1.1 静态类型和编译型

首先Go是静态类型，静态类型就是编译时就知道每一个变量的类型，得益于此，在编译的阶段就能够发现很多问题。而如果是动态语言，例如JavaScript，有些问题直到运行时才能发现。

Go是编译型语言，看到编译型大家脑子里可能会想到另外一个词解释型。两者的区别从字面上来理解其实已经可以看出来，我用一个简单的例子来类比一下。

- 编译型 去餐馆吃饭，点了菜之后，饭店会等所有的菜做好了再上
- 解释型 去餐馆吃饭，点了菜之后，陆陆续续的边吃边上

##### 1.2 跨平台

顾名思义，你写的Go源码在所有的系统都能够运行。

这点其实很好理解，例如Java的口号是"Write once, run anywhere"。我们都知道Java是编译型的语言，但是Java在编译的时候生成的是字节码，这个字节码与当前的操作系统无关，与CPU也无关。

这种字节码必须依赖Java虚拟机才能运行，而虚拟机会将操作系统和CPU之间的差异与用户屏蔽。对于编程的人来说这个过程其实无感知的。而对Java来说，语言本身的跨平台并不能代表代码可以跨平台。

Go的跨平台从某种方面来说，与Java类型，我们需要安装与当前操作系统相对应版本的Go。编译出来的可执行文件会根据操作系统的不同而有所不同。

##### 1.3 自动垃圾回收

与JVM一样，Go在运行时的内存管理（GC）由Go语言本身来管理，不需要程序员的参与，但是我们可以干预。

##### 1.4 原生的并发编程

何为原生？我们都知道，在Java中如果要实现并发， 需要外部的类库支持（Thread），而Go不需要从外部再引入任何依赖。支持使用关键字`go`即可。而且Java中是通过共享内存进行通信的，熟悉Go的应该都看过一句话“不要通过共享内存来通信，而应该通过通信来共享内存”

##### 1.5 完善的构建工具

从获取、编译、测试、安装、运行和分析等一系列流程都有自己的内置工具。例如获取可以使用`go get`命令来下载更新指定的代码包，并且对它们进行编译和安装，可以使用`go build` 对源码进行编译，用`go run`命令来运行Go的程序，用`go fmt`来快速格式化代码，统一代码风格。

##### 1.6 多范式编程

目前主流的编程范式有命令式编程、函数式编程和我们最熟悉的面向对象编程。在编写Go的代码的时候，我们可以选择使用面向对象的方法，也可以使用函数式编程的思想，相互结合，相辅相成。

例如，在Go里面也可以用接口来描述行为，也可以使用纯函数来避免出现副作用。因此，多范式编程就是指这个语言支持多种编程范式的。

##### 1.7 代码风格强统一

使用Go的内置工具`go fmt`即可快速的将代码格式化成官方统一的标准，以此来达到代码风格统一的目的。甚至可以用golangci-lint来检测你的语法跟内置的标准语法是否有冲突，完全可以将这个检测工具挂在git的钩子上，以此来达到强制的代码风格统一的目的。

##### 1.8 活跃的社区

还有一个很重要的特点是，国内的Go的社区十分的活跃，这对于Go在国内的普及起到了很大的作用。

### 二. 用Go的优势

##### **1. 简单**

简单应该是 Golang 最大的优势。Golang 的语言特性简单，学习周期短，熟悉其他编程语言的开发者基本都可以在短时间学会并写出各方面都还不错的代码。所谓各方面都还不错是说新手开发者写出来的代码和一些有经验的开发者写出来的代码差别并不会太大。

Golang 语言层面上的简洁性让一些新手程序员也能写出性能不错，bug 不多的程序，这个相比其他高级语言，比如 C++，是一个非常大的提升。MIT 的一个非常有名的课程 6.824 最开始使用功能的 C++，后来改成了 Golang，就是为了让大家可以专注于分布式算法本身，而不是陷入到语言细节的调试当中去。



##### **2. 兼顾开发效率和性能**

Golang 由于丰富的原生库和周边生态的支持，开发效率甚至可以比肩 Python。很多公司早期，或者项目早期的时候为了赶开发进度都会将开发效率放在第一位，比如 Python，PHP 这种动态语言。但是动态语言的性能劣势非常明显。现在的一个好现象就是 Golang 已经越来越多的被小公司采用了，毕竟写一个 http server 不过三行代码。

另外在开发效率的前提下，Golang 还具有非常高的性能。这一方面得益于静态语言，另一方面和其本身的语言设计也有很多关系。但是这里说的非常高的性能有点不太严谨，相比 C++/Java 这种老牌的高级语言，在某些场景下的 benchmark 还是要略逊一筹的。

##### **3. 语言级别的特性支持**

所谓语言级别的并发支持，就是使用 go func 直接启动一个 goroutine，外加 select/chan 等周边。

在Go中，使用协程来代替线程。而且一个协程所消耗的内存比线程少了很多倍。同样的物理设备限制，你可能只能启动最多几千个线程，而协程能够启动上百万个。而且不同的Goroutine可以通过信channel进行安全的通信。



### 三、go待改进的地方

#### **1. runtime**

支持 runtime 的编程语言一个无法绕开的问题就是 runtime 带来的一系列问题，比如性能损耗。在 rust 语言介绍自己的优势的时候有一点就是 no runtime。

Golang 的线程模型调度是 M:N，runtime 调度模型是 GMP 模型，伪抢占式的。简单点来说就是 runtime scheduler 可以类比成操作系统，但是缺乏硬件层面上对操作系统的支持，比如硬件中断，这就对 sheduler 的设计要求的非常高，但是 Golang 的实现并没有想象中的那么好。



#### **2. 并不能做到真正高并发高性能**

Golang 的高并发使用原生库来实现的话一般都是通过多 goroutine + select/channel，但是我们看 channel 源码，发现这个东西就是一个队列+一把锁。这也就意味着无法避免多个 goroutine 带来的竞争问题。我之前测试过在多个 goroutine 竞争同一个 channel 的时候，性能急剧下降。所以很多高性能的高并发程序如果是用 Golang 来写，很多都会避免使用 channel 来传递数据，而是借用类似 disruptor 的 ringbuffer 技术。

但是这并不是说 Golang 在高并发场景下性能不行，对于日常的 io 密集型的 web server，可以说性能是足够了。



#### **3. GC**

大概从 1.0 版本以来，GC 就一直被诟病。值得欣慰的是，Golang 的 GC 一直在发展，基本在每个版本都有一定的改进。1.8 版本是 GC 的一个里程碑，使用并发三色标记法的 GC 算法的stw 时间甚至达到了微秒级。目前社区貌似在讨论分代 GC 的方案。



#### **4. 包管理**

包管理也是一直被诟病，主要是一直没有一个官方的解决方案。直到去年官方终于开始有行动了，推出了 module，相对来说还是一个很不错的方案。



#### **5. 泛型**

Golang 没有支持泛型的很大一个原因是泛型太复杂。尽管很多人说 interface 也能实现泛型功能，但是这个泛型还是有一些本质的区别的。没有泛型确实是一个减分项。




