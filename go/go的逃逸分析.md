本文章来源于：<https://github.com/Zeb-D/my-review> ，请star 强力支持，你的支持，就是我的动力。

[TOC]

### 一、背景

最近几年负责了好几个业务线，各种异构语言，每种编程语言带来特性也大同小异，这种不同之处需要换角度进行技术选型时知道，说白了，这是培养你`技多不压身`的追求；

众所周知Java的门槛低，所以入门就很容易卷；golang对编程api快捷方便，适用高IO业务，但越深入越乏力；

rust适应于逻辑计算，但入门高，无GC（可以简单理解实时分配实时释放）；



回归主题，go和java都内置了GC操作，所以大家上来都可以梭一把，也不用担心像`C++`一样担心内存炸；

本文不讨论go的内存分配或GC算法，有兴趣的伙伴可以简单看下[核心原理--golang-runtime.md](./核心原理--golang-runtime.md);



### 二、逃逸情况

经常造成业务代码停顿大多数是由堆的GC造成的，所以我们能尽可能的把一些对象在栈内分配尽量些(但也不用走极端)，类似于Java的栈上分配(但不是TLAB)；

那么golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知，

如果变量通过了这些校验，它就可以在栈上分配。否则就说它逃逸了，必须在堆上分配。



那么哪些场景go是发生栈的逃逸到堆上：

- 在方法内把局部变量指针返回局部变量原本应该在栈中分配，在栈中回收。但是由 于返回时被外部引用，因此其生命周期大于栈，则溢出；
- 发送指针或带有指针的值到 channel 中。 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会 被释放；
- 在一个切片上存储指针或带指针的值。 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上；
- slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。如果切片背后的存 储要基于运行时的数据进行扩充，就会在堆上分配；
- 在 interface 类型上调用方法。 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配；



### 三、逃逸分析

说白了，逃逸分析可以在代码编译的时候可以大多数确定的，也意味着可以打开编译参数，实时查看我们的代码到底给堆造成了多大的压力；

分析工具:

1. 通过编译工具查看详细的逃逸分析过程(go build -gcflags '-m -l' main.go)；
2. 通过反编译命令查看go tool compile -S main.go

其中 编译参数(-gcflags)介绍:

- -N: 禁止编译优化 
- -l: 禁止内联(可以有效减少程序大小) 
- -m: 逃逸分析(最多可重复四次) 
- -benchmem: 压测时打印内存分配统计



### 四、示例

详情代码见 [gcflags_main.go](https://github.com/Zeb-D/go-util/blob/master/struct/leet_code/others/main/gcflags_main.go)



```
import "fmt"


type A struct {
	s string
}

// 这是上面提到的 "在方法内把局部变量指针返回" 的情况
func foo(s string) *A {
	a := new(A)
	a.s = s
	return a //返回局部变量a,在C语言中妥妥野指针，但在go则ok，但a会逃逸到堆
}

//go build -gcflags=-m gcflags_main.go 
func main() {
	a := foo("hello")
	b := a.s + " world"
	c := b + "!"
	fmt.Println(c) //这个fmt参数是个interface，所以c会逃逸到堆上
}
```



执行命令：

```
 go build -gcflags=-m gcflags_main.go 
```



输出逃逸结果：

```
➜  main git:(master) ✗ go build -gcflags=-m gcflags_main.go 
# command-line-arguments
./gcflags_main.go:26:6: can inline foo
./gcflags_main.go:34:10: inlining call to foo
./gcflags_main.go:37:13: inlining call to fmt.Println
./gcflags_main.go:26:10: leaking param: s
./gcflags_main.go:27:10: new(A) escapes to heap
./gcflags_main.go:34:10: main new(A) does not escape
./gcflags_main.go:35:11: main a.s + " world" does not escape
./gcflags_main.go:36:9: b + "!" escapes to heap
./gcflags_main.go:37:13: c escapes to heap
./gcflags_main.go:37:13: main []interface {} literal does not escape
./gcflags_main.go:37:13: io.Writer(os.Stdout) escapes to heap
<autogenerated>:1: (*File).close .this does not escape
➜  main git:(master) ✗ 
```

