本文章来源于：<https://github.com/Zeb-D/my-review> ，请star 强力支持，你的支持，就是我的动力。

[TOC]

------

### 背景

我的数据库占用空间太大，我把一个最大的表删掉了一半的数据，怎么表文件的大小还是没变？

一个 InnoDB 表包含两部分，即：表结构定义和数据。在 MySQL 8.0 版本以前，表结构是存在以.frm 为后缀的文件里。而 MySQL 8.0 版本，则已经允许把表结构定义放在系统数据表中了。因为表结构定义占用的空间很小，所以主要讨论的是表数据。

我们在删除整个表的时候，可以使用 drop table 命令回收表空间。但是，我们遇到的更多的删除数据的场景是删除某些行；



### 正确回收空间

#### innodb_file_per_table

表数据既可以存在共享表空间里，也可以是单独的文件。

这个行为是由参数 innodb_file_per_table 控制的：

> 这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；
>
> 这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。

从 MySQL 5.6.6 版本开始，它的默认值就是 ON 了。

我建议你不论使用 MySQL 的哪个版本，都将这个值设置为 ON。

因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 drop table 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。



#### 数据删除流程

InnoDB 里的数据都是用 B+ 树的结构组织的。自带主键锁+双向链表；

我们要删掉 ID=4 这个记录，InnoDB 引擎只会把  ID=4 这个记录标记为删除。如果之后要再插入一个 ID 在 2和 6之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。

> 那么如果我们删掉了一个数据页上的所有记录，会怎么样？
>
> 整个数据页就可以被复用了。

> 数据页的复用跟记录的复用是不同的。
>
> 记录的复用，只限于符合范围条件的数据。比如上面的这个例子，ID=4 这条记录被删除后，如果插入一个 ID 是 4的行，可以直接复用这个空间。但如果插入的是一个 ID 是 8的行，就不能复用这个位置了。

而当整个页从 B+ 树里面摘掉以后，可以复用到任何位置。以图 1 为例，如果将数据页 page A 上的所有记录删除以后，page A 会被标记为可复用。这时候如果要插入一条 ID=50 的记录需要使用新页的时候，page A 是可以被复用的。

如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。



如果我们用 delete 命令把整个表的数据删除呢？结果就是，所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。

delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过 delete 命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。



不止是删除数据会造成空洞，插入数据也会。

如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。



另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造成空洞的。



经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。

而重建表，就可以达到这样的目的。



#### 重建表

你可以使用 alter table A engine=InnoDB 命令来重建表。

> 在 MySQL 5.5 版本之前，这个命令的执行流程区别只是这个临时表 B 不需要你自己创建，MySQL 会自动完成转存数据、交换表名、删除旧表的操作。
>
> 花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表 A 的话，就会造成数据丢失。因此，在整个 DDL 过程中，表 A 中不能有更新。也就是说，这个 DDL 不是 Online 的。

> MySQL 5.6 版本开始引入的 Online DDL，对这个操作流程做了优化。
>
> 建立一个临时文件，扫描表 A 主键的所有数据页；
>
> 用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；
>
> 生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态；
>
> 临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3 的状态；
>
> 用临时文件替换表 A 的数据文件。



DDL 之前是要拿 MDL 写锁的，这样还能叫 Online DDL 吗？

alter 语句在启动的时候需要获取 MDL 写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。

为什么要退化呢？为了实现 Online，MDL 读锁不会阻塞增删改操作。

Online DDL 其实是会先获取MDL写锁, 再退化成MDL读锁；但MDL写锁持有时间比较短，所以可以称为Online； 而MDL读锁，不阻止数据增删查改，但会阻止其它线程修改表结构；



根据表 A 重建出来的数据是放在“tmp_file”里的，这个临时文件是 InnoDB 在内部创建出来的。整个 DDL 过程都在 InnoDB 内部完成。

对于 server 层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“**inplace**”名称的来源。

在存储引擎中实现，对于server端来说，无感知，这种方式叫做inplace;



如果你有一个 1TB 的表，现在磁盘间是 1.2TB，能不能做一个 inplace 的 DDL 呢？ 

答案是不能。因为，tmp_file 也是要占用临时空间的。





inplace 跟 Online 是不是就是一个意思？

DDL 的方式就两种，一种是COPY，一种是INPLACE。

mysql 5.6之前是 COPY 方式，mysql5.6引入 online，整个过程在引擎内部完成，对于 server 层没有创建临时表，就是 Inplace 方式。

所以，如果DDL过程是 online 的，那么一定是 Inplace 方式。反之不一定，比如添加全文索引



> 如何查看是否需要重建便呢。 
>
> 可以通过show table [from|in db_name] status like '%table_name%'命令查看表的容量的信息 
>
> 通过 Data_length 、Rows、Avg_row_length 计算碎片的大小： 碎片大小 = 数据总大小 - 实际表空间文件大小 数据总大小 = Data_length 
>
> 实际表空间文件大小 = rows * Avg_row_length 碎片大小（M） = (Data_length - （rows * Avg_row_length）) / 1024 /1024



optimize table、analyze table 和 alter table 这三种方式重建表的区别

optimize table：重建表 analyze table：重新对表的索引信息统计 optimize table：optimize table + analyze table





> Q:假设现在有人碰到了一个“想要收缩表空间，结果适得其反”的情况，看上去是这样的：一个表 t 文件大小为 1TB；对这个表执行 alter table t engine=InnoDB；发现执行完成后，空间不仅没变小，还稍微大了一点儿，比如变成了 1.01TB。
>
> A：在重建表的时候，InnoDB 不会把整张表占满，每个页留了 1/16 给后续的更新用。也就是说，其实重建表之后不是“最”紧凑的。

